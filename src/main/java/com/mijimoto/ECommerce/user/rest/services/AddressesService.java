/*
 * Created on 2025-10-29 ( 18:17:28 )
 * Generated by Telosys ( https://www.telosys.org/ ) version 3.3.0
 */
package com.mijimoto.ECommerce.user.rest.services;

import java.util.List;
import java.util.Optional;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.http.HttpStatus;

import com.mijimoto.ECommerce.user.persistence.entities.Addresses;
import com.mijimoto.ECommerce.user.persistence.repositories.AddressesRepository;
import com.mijimoto.ECommerce.user.rest.dto.AddressesDTO;
import com.mijimoto.ECommerce.common.rest.services.GenericService;

import com.mijimoto.ECommerce.shipping.persistence.repositories.CountriesRepository;
import com.mijimoto.ECommerce.shipping.persistence.repositories.ProvincesRepository;
import com.mijimoto.ECommerce.user.persistence.repositories.UsersRepository;
import com.mijimoto.ECommerce.user.persistence.repositories.UserPhoneNumbersRepository;

/**
 * REST service for entity "Addresses" <br>
 *
 * This service provides all the necessary operations required by the REST controller <br>
 * Enhanced to handle foreign key relationships with proper validation and error handling using
 * ResponseStatusException (Option A).
 *
 * @author Telosys
 *
 */
@Service
@Transactional
public class AddressesService extends GenericService<Addresses, AddressesDTO> {

    private static final Logger logger = LoggerFactory.getLogger(AddressesService.class);

    private final AddressesRepository repository;

    private final CountriesRepository countriesRepository;
    private final ProvincesRepository provincesRepository;
    private final UsersRepository usersRepository;
    private final UserPhoneNumbersRepository userphonenumbersRepository;

    /**
     * Constructor (usable for Dependency Injection)
     *
     * @param repository the repository to be injected
     * @param countriesRepository the Countries repository to be injected
     * @param provincesRepository the Provinces repository to be injected
     * @param usersRepository the Users repository to be injected
     * @param userphonenumbersRepository the UserPhoneNumbers repository to be injected
     */
    public AddressesService(AddressesRepository repository, CountriesRepository countriesRepository, ProvincesRepository provincesRepository, UsersRepository usersRepository, UserPhoneNumbersRepository userphonenumbersRepository) {
        super(Addresses.class, AddressesDTO.class);
        this.repository = repository;
        this.countriesRepository = countriesRepository;
        this.provincesRepository = provincesRepository;
        this.usersRepository = usersRepository;
        this.userphonenumbersRepository = userphonenumbersRepository;
    }
    
    /**
     * Returns the entity ID object from the given DTO
     *
     * @param dto the DTO
     * @return the entity ID
     */
    private Integer getEntityId(AddressesDTO dto) {
        return dto.getId();
    }

    /**
     * Validates foreign key references before persisting
     *
     * @param dto the DTO to validate
     * @throws ResponseStatusException if any FK reference is invalid (HTTP 400)
     */
    private void validateForeignKeyReferences(AddressesDTO dto) {
        // Validate Countries reference
        if (dto.getCountryId() != null && !countriesRepository.existsById(dto.getCountryId())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format("Invalid %s id: %s", "Countries", dto.getCountryId()));
        }
        // Validate Provinces reference
        if (dto.getProvinceId() != null && !provincesRepository.existsById(dto.getProvinceId())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format("Invalid %s id: %s", "Provinces", dto.getProvinceId()));
        }
        // Validate Users reference
        if (dto.getUserId() != null && !usersRepository.existsById(dto.getUserId())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format("Invalid %s id: %s", "Users", dto.getUserId()));
        }
        // Validate UserPhoneNumbers reference
        if (dto.getPhoneId() != null && !userphonenumbersRepository.existsById(dto.getPhoneId())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format("Invalid %s id: %s", "UserPhoneNumbers", dto.getPhoneId()));
        }
    }

    /**
     * Finds all occurrences of the entity
     *
     * @return list of DTOs
     */
    public List<AddressesDTO> findAll() {
        logger.debug("findAll()");
        Iterable<Addresses> all = repository.findAll();
        return entityListToDtoList(all);
    }

    /**
     * Finds the entity identified by the given PK
     *
     * @param id 
     * @return the DTO or null if not found
     */
    public AddressesDTO findById(Integer id) {
        Integer entityId = id;
        logger.debug("findById({})", entityId);
        Optional<Addresses> optionalEntity = repository.findById(entityId);
        return entityToDto(optionalEntity);
    }

    /**
     * Finds the entity by ID or throws exception
     *
     * @param id 
     * @return the DTO
     * @throws ResponseStatusException if not found (HTTP 404)
     */
    public AddressesDTO findByIdOrThrow(Integer id) {
        Integer entityId = id;
        logger.debug("findByIdOrThrow({})", entityId);
        Optional<Addresses> optionalEntity = repository.findById(entityId);
        if (!optionalEntity.isPresent()) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    String.format("Addresses with id %s not found", entityId));
        }
        return entityToDto(optionalEntity.get());
    }

    /**
     * Creates the given entity <br>
     * Validates foreign key references before creating
     *
     * @param dto the DTO to create
     * @return the created DTO with generated ID (if applicable)
     * @throws ResponseStatusException if FK validation fails (HTTP 400)
     */
    public AddressesDTO create(AddressesDTO dto) {
        logger.debug("create({})", dto);
        
        // Validate DTO
        validateDto(dto);
        
        // Validate foreign key references FIRST
        validateForeignKeyReferences(dto);
        
        // Auto-generated Primary Key - always create
        Addresses entity = dtoToEntity(dto);
        Addresses saved = repository.save(entity);
        return entityToDto(saved);
    }

    /**
     * Updates partially the given entity if it exists <br>
     * Only updates non-null fields from DTO <br>
     * Validates foreign key references for non-null FK fields
     *
     * @param id 
     * @param dto the DTO with fields to update
     * @return the updated DTO
     * @throws ResponseStatusException if entity not found (404) or FK validation fails (400)
     */
    public AddressesDTO partialUpdate(Integer id, AddressesDTO dto) {
        Integer entityId = id;
        logger.debug("partialUpdate({}, {})", entityId, dto);
        
        Optional<Addresses> optionalEntity = repository.findById(entityId);
        if (!optionalEntity.isPresent()) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    String.format("Addresses with id %s not found", entityId));
        }
        
        // Validate foreign key references for non-null FK fields
        validateForeignKeyReferences(dto);
        
        Addresses entity = optionalEntity.get();
        
        // Use GenericService's updateEntityFromDto which skips nulls
        updateEntityFromDto(entity, dto);
        
        Addresses updated = repository.save(entity);
        return entityToDto(updated);
    }

    /**
     * Deletes an entity by its PK
     *
     * @param id 
     * @throws ResponseStatusException if entity not found (HTTP 404)
     */
    public void deleteById(Integer id) {
        Integer entityId = id;
        logger.debug("deleteById({})", entityId);
        
        if (!repository.existsById(entityId)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    String.format("Addresses with id %s not found", entityId));
        }
        
        repository.deleteById(entityId);
    }

    /**
     * Checks if entity exists by ID
     *
     * @param id 
     * @return true if exists, false otherwise
     */
    public boolean existsById(Integer id) {
        Integer entityId = id;
        return repository.existsById(entityId);
    }




    // -----------------------------------------------------------------------------------------
    // DEPRECATED METHODS - Use the improved methods above instead
    // These are kept for backward compatibility but should not be used in new code
    // -----------------------------------------------------------------------------------------
    
    /*
    @Deprecated
    public void save(Integer id, AddressesDTO dto) {
        // DEPRECATED: This method has been replaced by update() which returns the updated entity
        // and provides better error handling with exceptions
        Integer entityId = id;
        logger.warn("DEPRECATED: save() called with entityId: {}. Use update() instead.", entityId);
        
        validateForeignKeyReferences(dto);
        
        // Force PK in DTO
        dto.setId(id);
        
        repository.save(dtoToEntity(dto));
    }
    */

    /* ------------------------------------------------------------------
     * The full `update()` method was intentionally moved to the end of
     * the file and commented out as requested. Keep it commented while
     * preserving the implementation for easy restoration or reference.
     * ------------------------------------------------------------------ */

   
    /**
     * Updates the given entity if it exists <br>
     * Validates foreign key references before updating
     *
     * @param dto the DTO to update
     * @return the updated DTO
     * @throws ResponseStatusException if entity not found (404) or FK validation fails (400)
     */
 /*
    public AddressesDTO update(AddressesDTO dto) {
        logger.debug("update({})", dto);
        
        // Validate DTO
        validateDto(dto);
        
        Integer entityId = getEntityId(dto);
        
        // Check if exists
        if (!repository.existsById(entityId)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    String.format("Addresses with id %s not found", entityId));
        }
        
        // Validate foreign key references AFTER confirming entity exists
        validateForeignKeyReferences(dto);
        
        Addresses entity = dtoToEntity(dto);
        Addresses updated = repository.save(entity);
        return entityToDto(updated);
    }
    */
}
