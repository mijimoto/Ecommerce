## --------------------------------------------------
#if ( $entity.isJoinEntity() )
#cancel("No SERVICE class for join entity")
#end
## --------------------------------------------------
#checkId($entity)
#parse("include/init_var_entity.vm")
#parse("include/java_header.vm")
##---------------------------------------------------------------------------------------
package ${target.javaPackageFromFolder(${SRC})};

import java.util.List;
import java.util.Optional;

#foreach( $import in $java.imports($entity.keyAttributes) )
import $import;
#end

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.http.HttpStatus;

import ${ROOT_PKG}.persistence.entities.${jpaEntityClass};
import ${ROOT_PKG}.persistence.repositories.${repositoryClass};
import ${ROOT_PKG}.rest.dto.${dtoClass};
import ${ROOT_PKG}.common.rest.services.GenericService;
#if ( $entity.hasCompositePrimaryKey() )
import ${ROOT_PKG}.persistence.entities.${jpaEntityIdClass};
#end

## Import related entity classes and repositories for FK handling
#foreach( $link in $entity.links )
#if ( $link.isCardinalityManyToOne() || $link.isCardinalityOneToOne() )
import ${ROOT_PKG}.persistence.repositories.${link.targetEntity.name}Repository;
#end
#end

/**
 * REST service for entity "${entity.name}" <br>
 *
 * This service provides all the necessary operations required by the REST controller <br>
 * Enhanced to handle foreign key relationships with proper validation and error handling using
 * ResponseStatusException (Option A).
 *
 * @author Telosys
 *
 */
@Service
@Transactional
public class ${serviceClass} extends GenericService<${jpaEntityClass}, ${dtoClass}> {

    private static final Logger logger = LoggerFactory.getLogger(${serviceClass}.class);

    private final ${repositoryClass} repository;

## Inject repositories for related entities
#foreach( $link in $entity.links )
#if ( $link.isCardinalityManyToOne() || $link.isCardinalityOneToOne() )
    private final ${link.targetEntity.name}Repository ${link.targetEntity.name.toLowerCase()}Repository;
#end
#end

    /**
     * Constructor (usable for Dependency Injection)
     *
     * @param repository the repository to be injected
#foreach( $link in $entity.links )
#if ( $link.isCardinalityManyToOne() || $link.isCardinalityOneToOne() )
     * @param ${link.targetEntity.name.toLowerCase()}Repository the ${link.targetEntity.name} repository to be injected
#end
#end
     */
    public ${serviceClass}(${repositoryClass} repository#foreach( $link in $entity.links )#if ( $link.isCardinalityManyToOne() || $link.isCardinalityOneToOne() ), ${link.targetEntity.name}Repository ${link.targetEntity.name.toLowerCase()}Repository#end#end) {
        super(${jpaEntityClass}.class, ${dtoClass}.class);
        this.repository = repository;
#foreach( $link in $entity.links )
#if ( $link.isCardinalityManyToOne() || $link.isCardinalityOneToOne() )
        this.${link.targetEntity.name.toLowerCase()}Repository = ${link.targetEntity.name.toLowerCase()}Repository;
#end
#end
    }
    
    /**
     * Returns the entity ID object from the given DTO
     *
     * @param dto the DTO
     * @return the entity ID
     */
    private $jpaEntityIdClass getEntityId(${dtoClass} dto) {
#if ( $entity.hasCompositePrimaryKey() )
        return new $jpaEntityIdClass($fn.argumentsListWithGetter("dto", $entity.keyAttributes));
#else
        return dto.${entity.keyAttribute.getter}();
#end
    }

    /**
     * Validates foreign key references before persisting
     *
     * @param dto the DTO to validate
     * @throws ResponseStatusException if any FK reference is invalid (HTTP 400)
     */
    private void validateForeignKeyReferences(${dtoClass} dto) {
#foreach( $link in $entity.links )
#if ( $link.isCardinalityManyToOne() || $link.isCardinalityOneToOne() )
#foreach( $linkAttribute in $link.attributes )
#set( $fkAttribute = $linkAttribute.originAttribute )
        // Validate ${link.targetEntity.name} reference
#if( $fkAttribute.name.toLowerCase() == "interface" )
        if (dto.getInterfaceField() != null && !${link.targetEntity.name.toLowerCase()}Repository.existsById(dto.getInterfaceField())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format("Invalid %s id: %s", "${link.targetEntity.name}", dto.getInterfaceField()));
        }
#else
        if (dto.${fkAttribute.getter}() != null && !${link.targetEntity.name.toLowerCase()}Repository.existsById(dto.${fkAttribute.getter}())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format("Invalid %s id: %s", "${link.targetEntity.name}", dto.${fkAttribute.getter}()));
        }
#end
#end
#end
#end
    }

    /**
     * Finds all occurrences of the entity
     *
     * @return list of DTOs
     */
    public List<${dtoClass}> findAll() {
        logger.debug("findAll()");
        Iterable<${jpaEntityClass}> all = repository.findAll();
        return entityListToDtoList(all);
    }

#if ( $entity.hasCompositePrimaryKey() )
#set( $entityIdInit = "new $jpaEntityIdClass($fn.argumentsList($entity.keyAttributes))" )
#else
#set( $entityIdInit = "${entity.keyAttribute.name}" )
#end
    /**
     * Finds the entity identified by the given PK
     *
#foreach( $attribute in $entity.keyAttributes )   
     * @param $attribute.name 
#end
     * @return the DTO or null if not found
     */
    public ${dtoClass} findById($fn.argumentsListWithType($entity.keyAttributes)) {
        ${jpaEntityIdClass} entityId = ${entityIdInit};
        logger.debug("findById({})", entityId);
        Optional<${jpaEntityClass}> optionalEntity = repository.findById(entityId);
        return entityToDto(optionalEntity);
    }

    /**
     * Finds the entity by ID or throws exception
     *
#foreach( $attribute in $entity.keyAttributes )   
     * @param $attribute.name 
#end
     * @return the DTO
     * @throws ResponseStatusException if not found (HTTP 404)
     */
    public ${dtoClass} findByIdOrThrow($fn.argumentsListWithType($entity.keyAttributes)) {
        ${jpaEntityIdClass} entityId = ${entityIdInit};
        logger.debug("findByIdOrThrow({})", entityId);
        Optional<${jpaEntityClass}> optionalEntity = repository.findById(entityId);
        if (!optionalEntity.isPresent()) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    String.format("${entity.name} with id %s not found", entityId));
        }
        return entityToDto(optionalEntity.get());
    }

    /**
     * Creates the given entity <br>
     * Validates foreign key references before creating
     *
     * @param dto the DTO to create
     * @return the created DTO with generated ID (if applicable)
     * @throws ResponseStatusException if FK validation fails (HTTP 400)
     */
    public ${dtoClass} create(${dtoClass} dto) {
        logger.debug("create({})", dto);
        
        // Validate DTO
        validateDto(dto);
        
        // Validate foreign key references FIRST
        validateForeignKeyReferences(dto);
        
#if ($entity.hasAutoIncrementedKey() )
        // Auto-generated Primary Key - always create
        ${jpaEntityClass} entity = dtoToEntity(dto);
        ${jpaEntityClass} saved = repository.save(entity);
        return entityToDto(saved);
#else    
        // Check if already exists
        if (repository.existsById(getEntityId(dto))) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    String.format("${entity.name} with this ID already exists: %s", getEntityId(dto)));
        }
        
        ${jpaEntityClass} entity = dtoToEntity(dto);
        ${jpaEntityClass} saved = repository.save(entity);
        return entityToDto(saved);
#end
    }

    /**
     * Updates partially the given entity if it exists <br>
     * Only updates non-null fields from DTO <br>
     * Validates foreign key references for non-null FK fields
     *
#foreach( $attribute in $entity.keyAttributes )   
     * @param $attribute.name 
#end
     * @param dto the DTO with fields to update
     * @return the updated DTO
     * @throws ResponseStatusException if entity not found (404) or FK validation fails (400)
     */
    public ${dtoClass} partialUpdate($fn.argumentsListWithType($entity.keyAttributes), ${dtoClass} dto) {
        ${jpaEntityIdClass} entityId = ${entityIdInit};
        logger.debug("partialUpdate({}, {})", entityId, dto);
        
        Optional<${jpaEntityClass}> optionalEntity = repository.findById(entityId);
        if (!optionalEntity.isPresent()) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    String.format("${entity.name} with id %s not found", entityId));
        }
        
        // Validate foreign key references for non-null FK fields
        validateForeignKeyReferences(dto);
        
        ${jpaEntityClass} entity = optionalEntity.get();
        
        // Use GenericService's updateEntityFromDto which skips nulls
        updateEntityFromDto(entity, dto);
        
        ${jpaEntityClass} updated = repository.save(entity);
        return entityToDto(updated);
    }

    /**
     * Deletes an entity by its PK
     *
#foreach( $attribute in $entity.keyAttributes )   
     * @param $attribute.name 
#end
     * @throws ResponseStatusException if entity not found (HTTP 404)
     */
    public void deleteById($fn.argumentsListWithType($entity.keyAttributes)) {
        ${jpaEntityIdClass} entityId = ${entityIdInit};
        logger.debug("deleteById({})", entityId);
        
        if (!repository.existsById(entityId)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    String.format("${entity.name} with id %s not found", entityId));
        }
        
        repository.deleteById(entityId);
    }

    /**
     * Checks if entity exists by ID
     *
#foreach( $attribute in $entity.keyAttributes )   
     * @param $attribute.name 
#end
     * @return true if exists, false otherwise
     */
    public boolean existsById($fn.argumentsListWithType($entity.keyAttributes)) {
        ${jpaEntityIdClass} entityId = ${entityIdInit};
        return repository.existsById(entityId);
    }

#* -----------------------------------------------------------------------------------------
   Specific "finders" for foreign key relationships
   -----------------------------------------------------------------------------------------
#foreach( $link in $entity.links )
  #if( $link.isCardinalityManyToOne() )
    #foreach( $linkAttribute in $link.attributes )
      #set( $fkAttribute = $linkAttribute.originAttribute )

      /**
       * Finds entities by ${link.targetEntity.name} reference
       *
       * @param ${fkAttribute.name} the ${link.targetEntity.name} ID
       * @return list of DTOs
       */
      public List<${dtoClass}> findBy${fn.capitalize($link.targetEntity.name)}(${fkAttribute.type} ${fkAttribute.name}) {
          logger.debug("findBy${fn.capitalize($link.targetEntity.name)}({})", ${fkAttribute.name});
          List<${jpaEntityClass}> list = repository.findBy${fn.capitalize($fkAttribute.name)}(${fkAttribute.name});
          return entityListToDtoList(list);
      }
    #end
  #end
#end
*#


    // -----------------------------------------------------------------------------------------
    // DEPRECATED METHODS - Use the improved methods above instead
    // These are kept for backward compatibility but should not be used in new code
    // -----------------------------------------------------------------------------------------
    
    /*
    @Deprecated
    public void save($fn.argumentsListWithType($entity.keyAttributes), ${dtoClass} dto) {
        // DEPRECATED: This method has been replaced by update() which returns the updated entity
        // and provides better error handling with exceptions
        ${jpaEntityIdClass} entityId = ${entityIdInit};
        logger.warn("DEPRECATED: save() called with entityId: {}. Use update() instead.", entityId);
        
        validateForeignKeyReferences(dto);
        
        // Force PK in DTO
#foreach( $attribute in $entity.keyAttributes )
        dto.${attribute.setter}(${attribute.name});
#end
        
        repository.save(dtoToEntity(dto));
    }
    */

    /* ------------------------------------------------------------------
     * The full `update()` method was intentionally moved to the end of
     * the file and commented out as requested. Keep it commented while
     * preserving the implementation for easy restoration or reference.
     * ------------------------------------------------------------------ */

   
    /**
     * Updates the given entity if it exists <br>
     * Validates foreign key references before updating
     *
     * @param dto the DTO to update
     * @return the updated DTO
     * @throws ResponseStatusException if entity not found (404) or FK validation fails (400)
     */
 /*
    public ${dtoClass} update(${dtoClass} dto) {
        logger.debug("update({})", dto);
        
        // Validate DTO
        validateDto(dto);
        
        ${jpaEntityIdClass} entityId = getEntityId(dto);
        
        // Check if exists
        if (!repository.existsById(entityId)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    String.format("${entity.name} with id %s not found", entityId));
        }
        
        // Validate foreign key references AFTER confirming entity exists
        validateForeignKeyReferences(dto);
        
        ${jpaEntityClass} entity = dtoToEntity(dto);
        ${jpaEntityClass} updated = repository.save(entity);
        return entityToDto(updated);
    }
    */
}
